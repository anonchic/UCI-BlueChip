/*
Added header information. can be retrived from binaries w/ ident <filename>
*/
.seg "data"
rcsid: 
        .ascii "$Id: cwp.s,v 1.2 91/01/10 14:58:01 rudi Exp $"
.align 8
.seg "text"

/*******************************************************************************


	SYNOPSIS:

	This diagnostic tests the various instructions and sequences
	which affect and depend upon the CWP. This includes the save
	and restore instructions, and the subroutine linkage sequence.

	ERROR INDICATION:

	Registers %g1, %g2 and %g3 are used to accumulate errors.
	When the label "stop" is reached, these registers should
	contain 0. At "stop", an infinite loop is entered.

	Register %g4 is used to indicate completion of the diagnostic.
	If EVERY test was run (with or without errors) this register will
	contain -1. Otherwise it will be zero.

	some errors (such as traps) cannot be recovered from so the diagnostic
	is terminated early, and %g4 will not be set.

	If %g1, %g2 or %g3 does not contain zero, each bit set corresponds to a
	detected error, with bits in %g2 representing errors 32 to 63,
	and bits in %g3 representing errors 64 - 95.
	For each set bit (n), find the call to:

		check_error(n ...)

	in this source. This is the point at which the error was detected.


*******************************************************************************/

/* registers used for recording errors */

#define ERR_RET %r1
#define ERR_RET_NUM 1

#include "err_incr.h"
#include "err_macro.h"
new_init(cwp)



/******************************************************************************

	TRAP TABLE

*******************************************************************************/

#include "crueltt.S"

/******************************************************************************

	STARTUP ROUTINE

*******************************************************************************/

#include "su_super.S"

/*******************************************************************************

	MAIN PROGRAM

*******************************************************************************/

main:
		save	%sp, -64, %sp

/*******************************************************************************

	UNUSUAL SUBROUTINE LINKAGES

*******************************************************************************/

		call	set_sub
		nop
		mov	99, %o0
		call	min_sub		! adds it's arguments
		mov	88, %o1
					! check for error
		cmp	%o0, 99+88
		check_error(12, bne)

		mov	99+88, %o0
		call	test_sub
		mov	-1, %o1
					! check for error
		cmp	%o0, 1
		check_error(13, bne)

		! test a sequence of save and restore instructions

		mov	1, %o0
		save	%o0, %o0, %o0	! double %o0, and put it into new %o0
		restore	%o0, %o0, %o0	! double %o0, and put it into new %o0
		save	%o0, %o0, %o0
		save	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		save	%o0, %o0, %o0
		save	%o0, %o0, %o0
		save	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		save	%o0, %o0, %o0
		save	%o0, %o0, %o0
		save	%o0, %o0, %o0
		save	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		restore	%o0, %o0, %o0
		set	1024*1024, %l0
		cmp	%o0, %l0
		check_error(14, bne)



/*******************************************************************************

	END OF TEST CASES

*******************************************************************************/


		b	stop
		nop


stop: b testok; nop
		b	stop		! enter an infinite loop for Daisy
		nop

		ret			! normal procedure end
		restore



/*******************************************************************************

	SUPPORT ROUTINES

*******************************************************************************/

#include "err_subr.S"

min_sub:	
	! the minimum size subroutine that might reasonably
	! be generated by a compiler + optimizer.
	! also tests save and restore register access.
	! adds the input arguments and returns the result

		save	%o0, %o1, %l0	! l0 = sum of first 2 args
		ret
		restore	%l0, 0, %o0	! return sum

set_sub:
		save	%sp, 64, %sp	! set up stack pointer
		mov	-1, %l4		! checked for by test_sub
		ret
		restore
test_sub:
	! returns 1 if the first two arguments match the
	! first two local registers, otherwise returns 0.

		save	%sp, 64, %sp
		cmp	%i0, %l0
		bne	test_sub_fail
		nop
		cmp	%i1, %l4
		bne	test_sub_fail
		mov	1, %i0
		ret
		restore
test_sub_fail:
		mov	0, %i0
		ret
		restore
